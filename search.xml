<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue常见优化方法</title>
      <link href="/2024/09/16/vue-common-optimizations/"/>
      <url>/2024/09/16/vue-common-optimizations/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-常见优化方法"><a href="#Vue-常见优化方法" class="headerlink" title="Vue 常见优化方法"></a>Vue 常见优化方法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Premature optimization is the root of all evil. — Donald Knuth</p><blockquote><p>过早优化是万恶之源。这话也许有些夸张，但“过早优化”的危害我觉得不能忽视。同时，我觉得“过早优化”的概念不专属于编写程序，生活中的示例也比比皆是。不妨你看看下面这些情形你是否遇到过：</p></blockquote></blockquote><ol><li><p>当你开始学一门程序语言的时候(比如 C#)，你花不少的时间去选择哪门程序语言，比较各种语言的优劣，在五花八门的语言面前犹豫不决，这个想学，那个也不想放弃，结果都是学个半路子。或者你一开始想如果可以精通开发工具（比如 Visual Studio Code）一定如虎添翼，进而提高开发效率，于是一开始你就花很多时间去研究开发工具，而忘记自己学习的重点是语言本身，而非工具…</p></li><li><p>当你学习一门外语(比如英语)的时候，一开始，你花了很多的时间去下载有关英语资料，花了很多的时间去找英语书籍，以为有了这些资料和书籍就可以学好英文，而不是一开始就踏踏实实的从单词、语法开始，结果后来资料下载了一大堆，书籍买了不少，却没有坚持下去…</p></li><li><p>你想搞体育锻炼，比如打羽毛球，于是一开始你花大量时间去买球衣、球鞋、球拍等装备，可没连几天，你发现自己开始三天打鱼两天晒网了，最后，那些装备都起了灰，也没锻炼几次…</p></li><li><p>你想做时间管理(Getting Things Done),于是你研究各种时间管理的资料，上各种时间管理技巧的网站，比如 lifehack、 digg 、gtdlife，下载对最流行的 GTD 的管理软件，以节省时间的名义浪费时间，结果每天都很浮躁，甚至不能做到实实在在把每天的计划都落实,拖拖拉拉…</p></li><li><p>你有没有这样的体验，一本书你总是对开头的部分看的最仔细，后面的章节没坚持看下去，下次又重复这种循环。当你计划做一件事的时候，总是规划的非常完美，几乎考虑每个细节，但却没有认认真真、一步一步执行，或者过早完美计划，反而让你缩手缩脚，犹豫不前，瞻前顾后，顾此失彼，最后虎头蛇尾…</p></li><li><p>比如，如果我有了钱，我就怎样怎样享受快乐，比如，如果我将来有了很多的时间，我就会花更多的时间陪家人或锻炼……</p></li></ol><p>这样类似的例子不止于此。</p><p>过早优化对大的问题在于：过早关注不重要的部分，而<strong>忽略行动</strong>和<strong>目标本身</strong>。以静态的思维来优化，殊不知，事务发展总是动态的，“优化”是需要长期的实践积累才可以获得。出发点是好的，但往往好心办坏事，折腾大量的时间，做了很多不该做的，而该做的、重要的反而没做。强化外部条件、工具等外在，而忽略内在因素和行动本身，或者，过多期望将来，而忽略当下眼前。</p><p><strong>活在当下，实实在在做好手头的事，是避免“过早优化”最好的方法之一。</strong></p><h2 id="优化时机"><a href="#优化时机" class="headerlink" title="优化时机"></a>优化时机</h2><p>    写正确的程序比写正确的高性能程序要容易太多，太多，太多···🤩。所以在缺省情况下，不要让代码集中在执行速度更快，性能更好方面，而是首先把精力放在使代码尽可能性的结构清晰和高可读性的基础上。清晰的代码易于书写正确，易于理解，易于重构，并且易于优化。总的来说，优化(甚至包括复杂化)总是在稍后引入，并且只是在<strong>必要的场景</strong>下。</p><h2 id="优化的两面性"><a href="#优化的两面性" class="headerlink" title="优化的两面性"></a>优化的两面性</h2><p>利 👍：</p><blockquote><ol><li>提高执行速度：优化后的代码可以更快的启动和执行，对于需要处理大量数据或快速响应的 app 尤其重要。</li><li>减少资源消耗：优化可以减少 CPU 和内存的使用，从而降低硬件成本。</li><li>提升用户体验：更快的程序响应时间可以提供更流畅的用户体验。</li><li>增强可扩展性：更好地处理增加地负载，使其更容易扩展。</li></ol></blockquote><p>弊 👎：</p><blockquote><ol><li>增加复杂性：优化代码使代码难以理解和维护。</li><li>可能引入未知错误：过度优化代码可能有时会引入难以发现地错误。</li><li>开发时间和成本增加：性能优化可能需要更多的人力和额外的时间来分析和重写代码。</li><li>降低可读性：为提高性能，开发者可能会牺牲代码的可读性。</li></ol></blockquote><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="1️⃣使用-key"><a href="#1️⃣使用-key" class="headerlink" title="1️⃣使用 key"></a>1️⃣使用 key</h3><p>对于通过循环生成的列表，应给每个列表项一个<strong>稳定</strong>且<strong>唯一</strong>的 key，这有利于在列表变动时尽量少的操作元素。</p><h3 id="2️⃣长列表性能优化之使用冻结对象"><a href="#2️⃣长列表性能优化之使用冻结对象" class="headerlink" title="2️⃣长列表性能优化之使用冻结对象"></a>2️⃣长列表性能优化之使用冻结对象</h3><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据。因此，在大量数据展示的情况下，如果能禁止 Vue 劫持我们的数据，能够很明显的减少组件初始化的时间。</p><p>用法：获取数据后，使用 <code>Object.freeze(obj)</code> 冻结对象，使其不能再被修改。</p><p>freezeData 冻结的对象不会被响应化；normalData 正常的对象会被 ProxySetter 响应化。</p><h3 id="3️⃣使用函数式组件"><a href="#3️⃣使用函数式组件" class="headerlink" title="3️⃣使用函数式组件"></a>3️⃣使用函数式组件</h3><p>函数式组件本质就是一个函数用来做页面数据的纯渲染，不会生成到 Vue 的组件树中为其生成组件实例，函数的返回值就是虚拟 DOM，在提高程序性能的同时也减少了 js 内存的占用。</p><p>在 Vue 3 中，所有的函数式组件都是用普通函数创建的。</p><p>换句话说，不需要像 Vue 2 中的函数式组件一样定义 { functional: true } 组件选项。</p><p>具体使用👉 <a href="https://v2.cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6">函数式组件</a>(Vue 2)</p><h3 id="4️⃣使用计算属性"><a href="#4️⃣使用计算属性" class="headerlink" title="4️⃣使用计算属性"></a>4️⃣使用计算属性</h3><p>如果模板中某个数据会使用多次，并且该数据是通过计算机得到的，使用计算属性以缓存它们。</p><h3 id="5️⃣非实时绑定的表单项"><a href="#5️⃣非实时绑定的表单项" class="headerlink" title="5️⃣非实时绑定的表单项"></a>5️⃣非实时绑定的表单项</h3><p>当使用 v-model 绑定一个表单项后，当用户改变表单项的值或状态，也会随之改变数据，从而导致 vue 发生重新渲染 (rerender)，这会带来一些性能的开销。</p><p>我们可以通过使用 v-model.lazy 或不使用 v-model 的方式解决该问题，但是要注意这样可能会导致在某一个时间段内数据和表单项的值是不一致的。</p><h3 id="6️⃣保持对象引用稳定"><a href="#6️⃣保持对象引用稳定" class="headerlink" title="6️⃣保持对象引用稳定"></a>6️⃣保持对象引用稳定</h3><p>在绝大部分情况下，vue 触发 rerender 的时机是其依赖的数据发生变化。</p><p>若数据没有发生变化，哪怕给数据重新赋值了，vue 也是不会做出任何处理的。</p><p>以下是 vue 判断数据是否发生变化的源码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function hasChanged(x, y) {</span><br><span class="line">    if (x === y) {</span><br><span class="line">        return x ===  &amp;&amp; 1 / x !== 1 / y</span><br><span class="line">    } else {</span><br><span class="line">        return x === x || y === y</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因此，如果需要，只要能保证组件的依赖数据不会发生变化，组件就不会重新渲染。</p><p>对于原始数据类型，保持其值不变即可； 对于对象类型，保持其引用不变即可。</p><p>从另一方面来说，由于可以通过保持属性引用稳定来避免子组件的重渲染，那么我们应细分组件来尽量避免多余的渲染。</p><h3 id="7️⃣使用-v-show-替代-v-if"><a href="#7️⃣使用-v-show-替代-v-if" class="headerlink" title="7️⃣使用 v-show 替代 v-if"></a>7️⃣使用 v-show 替代 v-if</h3><p>对于频繁切换显示/隐藏状态的元素，使用 v-show 可以保证虚拟 DOM 树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量 dom 元素的节点，这一点极其重要！！！</p><p><strong>关键词</strong>：频繁切换显示/隐藏状态；内部包含大量 dom 元素</p><h3 id="8️⃣使用延迟装载-defer"><a href="#8️⃣使用延迟装载-defer" class="headerlink" title="8️⃣使用延迟装载(defer)"></a>8️⃣使用延迟装载(defer)</h3><p>JS 传输完成后，浏览器开始执行 JS 构造页面。</p><p>但可能一开始要渲染的组件太多，不仅 JS 执行的时间很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏。</p><p>使用延迟装载，让组件按照指定的先后顺序依次一个一个渲染出来。</p><blockquote><p>延迟装载本质上就是利用 <strong>requestAnimationFrame</strong> 事件分批渲染内容。</p></blockquote><h3 id="9️⃣使用-keep-alive-页面缓存"><a href="#9️⃣使用-keep-alive-页面缓存" class="headerlink" title="9️⃣使用 keep-alive 页面缓存"></a>9️⃣使用 keep-alive 页面缓存</h3><p>在 Vue 中，组件通常是动态创建和销毁的，当切换到另一个页面或组件时，之前的组件会被销毁，再次进入时会重新创建和初始化。这样可能导致组件的状态丢失，需要重新初始化，增加了资源的消耗。</p><p>KeepAlive (Vue 内置组件)解决了这个问题，它可以<strong>将组件的实例缓存起来</strong>，而不是销毁它，使得组件在<strong>再次进入时保持之前的状态</strong>，以及避免重复的创建和初始化过程。这样可以大幅度提高组件的加载速度和性能。</p><p><strong>keep-alive 实现原理</strong>：</p><ul><li><p>组件的缓存是通过一个名为 cache 的对象来管理的，该对象会保存被缓存的组件实例。</p></li><li><p>当切换到一个被缓存的组件时，Vue 首先检查 cache 对象中是否已经有该组件的缓存实例。如果有，就直接从缓存中取出该实例；如果没有，就创建一个新的组件实例并将其缓存起来。</p></li></ul><p><strong>keep-alive 基础用法</strong> (IndexView.vue)：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;RouterView v-slot="{ currentComponent }"&gt;</span><br><span class="line">        &lt;!-- 全局过渡动画 --&gt;</span><br><span class="line">        &lt;Transition name="fade"&gt;</span><br><span class="line">            &lt;!-- max最大缓存实例数(类似一个 LRU 缓存)--&gt;</span><br><span class="line">            &lt;KeepAlive :max="KeepAliveMaxNum"&gt;</span><br><span class="line">                &lt;!-- 需要缓存起来的常用组件 key确保组件的正确缓存 --&gt;</span><br><span class="line">                &lt;component</span><br><span class="line">                    :is="currentComponent"</span><br><span class="line">                    :key="currentComponent"</span><br><span class="line">                &gt;</span><br><span class="line">                &lt;/component&gt;</span><br><span class="line">            &lt;/KeepAlive&gt;</span><br><span class="line">        &lt;/Transition&gt;</span><br><span class="line">    &lt;/RouterView&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><p>具体使用👉 <a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html#keepalive">KeepAlive</a></p><h3 id="🔟包体积与-Tree-shaking-优化"><a href="#🔟包体积与-Tree-shaking-优化" class="headerlink" title="🔟包体积与 Tree-shaking 优化"></a>🔟包体积与 Tree-shaking 优化</h3><p>默认情况下，通过import语法导入的第三方依赖包，最终会全部打包到一个js文件中，会导致单文件体积过大大，在网速底下时会阻塞网页加载，影响用户体验。</p><p>性能优化的主要方向：</p><ol><li><p>路由懒加载：项目启动伊始，如果直接加载所有的组件，首屏加载就比较慢，可以配置路由按需加载。</p></li><li><p>去除生产版console.log的打印输出：打包上线后的console语句没有任何作用，所以我们应该移除它，除去手动移除，还可以使用插件的方式来移除代码里的console语句。<br>安装依赖 : <code>yarn add terser-webpack-plugin -D (npm i terser-webpack-plugin -D)</code></p></li><li><p>开发版使用依赖项，生产版使用在线CDN：使用CDN，减少包的体积。 将线上环境中用到的一些依赖，使用CDN网络节点的方式进行引用，而不是直接打包到包里。</p></li><li><p>项目打包及配置：yarn build得到一个dist目录,这个目录包含了项目中所有的页面, 样式, 业务, 第三方包等，打包的过程中，会对代码进行压缩合并, 版本降级, 语法转换等。</p></li></ol><p>具体使用👉 <a href="https://cn.vuejs.org/guide/best-practices/performance#bundle-size-and-tree-shaking">包体积与 Tree-shaking 优化</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在实际生产中 Vue 项目的性能优化方法远不止这些，这篇关于 Vue 项目中常见的优化方法就介绍到这了🙋‍♂️。</p><p>via: <a href="https://www.watch-life.net/life-thinking/no-premature-optimization.html">https://www.watch-life.net/life-thinking/no-premature-optimization.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的Git提交规范类型</title>
      <link href="/2024/09/09/git-commit/"/>
      <url>/2024/09/09/git-commit/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的Git提交规范类型"><a href="#常见的Git提交规范类型" class="headerlink" title="常见的Git提交规范类型"></a>常见的Git提交规范类型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时在Gitee, GitHub, GitCode等等众多代码托管平台上，阅读其他优秀项目及框架源码时经常看到别人提交的代码记录中包含一些<strong>feat</strong>, <strong>fix</strong>,<strong>chore</strong>,<strong>refactor</strong>等等。第一次看到不以为然，只是觉得看不懂为什么要这样写，明明可以直接简单明了的添加提交信息就行了，但为什么要 <del>画足添蛇</del> 画蛇添足呢? 其实依据这种规范书写提交信息的主要目的是为了<strong>提高提交记录的可读性和自动化处理能力。</strong>，然而在我平时提交时几乎不会区分这些，而是直接写下做了什么的提交信息，草草了之，但为了日后能进一步提高书写规范，今天就来好好整理一下这些“繁文缛节”。</p><p>Git正确的提交规范：</p><pre>git commit -m "subject + : + space + message"</pre><p></p><hr><h2 id="规范类型"><a href="#规范类型" class="headerlink" title="规范类型"></a>规范类型</h2><p><em>注：以下 [gc -m] 指代 git commit -m</em></p><ol><li><strong>feat</strong>(feature): 新功能<ul><li>用于描述新增加的功能</li><li>例如：gc -m “feat: 添加网页icon图标”</li></ul></li><li><strong>fix</strong>: 修补bug<ul><li>用于描述修复了某个bug</li><li>例如：gc -m “fix: 修复用户访问权限的问题”</li></ul></li><li><strong>docs</strong>(documentation)<ul><li>用于对文档的修改，如README.md文件的更新</li><li>例如：gc -m “docs: 更新后端接口文档”</li></ul></li><li><strong>style</strong>: 代码格式(不影响代码运行的变动)<ul><li>用于格式的修正，比如代码缩进或其他样式的改动，不涉及代码逻辑变化</li><li>例如：gc -m “style: 使用prettier格式化代码”</li></ul></li><li><strong>refactor</strong>: 重构代码或重命名<ul><li>用于重构代码，既不是新增功能，也不是修复bug的</li><li>例如：gc -m “控制台优化重构 | 侧边栏收缩icon图标重命名”</li></ul></li><li><strong>pref(performance improvement)</strong>: 性能优化<ul><li>用于提高代码性能的更改</li><li>例如：gc -m “优化查询用户列表的速度”</li></ul></li><li><strong>test</strong>: 增加测试<ul><li>用于添加或修改测试用例</li><li>例如：gc -m “test: 为登录功能添加单元测试”</li></ul></li><li><strong>chore</strong>: 构建过程或辅助工具的变动<ul><li>用于更新构建工具，依赖等</li><li>例如：gc -m “chore: 更新yarn依赖”</li></ul></li><li><strong>build</strong>: 影响构建系统或外部依赖的更改(例如：webpack，npm)<ul><li>例如：gc -m “build: 更新webpack配置”</li></ul></li><li><strong>ci</strong>: 持续集成的配置文件或脚本的变动(例如：Travis，BrowserStack)<ul><li>例如gc -m “ci: 更新Travis配置项”</li></ul></li><li><strong>revert</strong>: 撤销某次提交<ul><li>用于撤销之前的某次提交</li><li>例如：gc -m “revert: 撤销 commit 123456abc”</li></ul></li><li><strong>merge</strong>: 分支合并<ul><li>用于合并分支的提交</li><li>例如：gc -m “merge: 合并 /feature/register 分支”</li></ul></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是几种常见的代码提交规范类型，这些类型有助于保持代码提交记录的清晰性和可读性，使用规范的提交信息可以让项目更加模块化，易于维护和理解，同时也便于团队协作时其他开发人员理解每次提交的意图和信息内容，从而提高代码的可维护性和质量🥳。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在JavaScript中交换两个数组元素</title>
      <link href="/2024/09/05/swap-elements/"/>
      <url>/2024/09/05/swap-elements/</url>
      
        <content type="html"><![CDATA[<h1 id="交换两个数组元素的方法"><a href="#交换两个数组元素的方法" class="headerlink" title="交换两个数组元素的方法"></a>交换两个数组元素的方法</h1><p>在 JavaScript 中有时需要交换数组中的两个元素，可以使用以下三种方法之一。</p><h2 id="临时变量-temp"><a href="#临时变量-temp" class="headerlink" title="临时变量 temp"></a>临时变量 temp</h2><p>使用一个临时变量 temp 分为以下三个步骤：</p><ol><li>创建一个临时变量来保存第一个元素的值；</li><li>将第一个元素的值设置为第二个元素的值；</li><li>将第二个元素的值设置为临时变量中的值。</li></ol><pre>    <code style="font-size: 20px; background-color: rgba(31,31,31,.31)">let myArray = [1, 2, 3, 4, 5];const temp = myArray[0];myArray[0] = myArray[1];myArray[1] = temp;console.log(myArray); // [2, 1, 3, 4, 5]</code></pre><p>封装为函数：</p><pre>    <code style="font-size: 20px; background-color: rgba(31,31,31,.31)">const swapElements =(array, index1, index2) =&gt; {    let temp = array[index1];    array[index1] = array[index2];    array[index2] = temp;};let myArray = [1, 2, 3, 4, 5];swapElements(myArray, 0, 1);console.log(myArray); // [2, 1, 3, 4, 5]</code></pre><h2 id="解构赋值-推荐"><a href="#解构赋值-推荐" class="headerlink" title="解构赋值(推荐)"></a>解构赋值(推荐)</h2><p>只需创建一个新的数组，其中包含按特定顺序排列的两个元素，然后将其分配给一个新的数组，其中包含按相反顺序排列的两个元素。实现如下：</p><pre>    <code style="font-size: 20px; background-color: rgba(31,31,31,.31)">let myArray = [1, 2, 3, 4, 5];[myArray[0], myArray[1]] = [myArray[1], myArray[0]];console.log(myArray); // [2, 1, 3, 4, 5]</code></pre><p>封装为函数：</p><pre>    <code style="font-size: 20px; background-color: rgba(31,31,31,.31)">const swapElements =(array, index1, index2) =&gt;[myArray[index1], myArray[index2]] = [myArray[index2], myArray[index1]];let myArray = [1, 2, 3, 4, 5];swapElements(myArray, 0, 1);console.log(myArray); // [2, 1, 3, 4, 5]</code></pre><h2 id="Splice-方法"><a href="#Splice-方法" class="headerlink" title="Splice() 方法"></a>Splice() 方法</h2><p>使用 ES6 中的 <code>splice()</code>数组方法：从一个数组中移除一个或多个元素，然后用任何指定的元素替换这些元素。</p><p><code>splice()</code>方法返回值：</p><ul><li>一个包含了删除的元素的数组。</li><li>如果只移除一个 a 元素，则只返回一个 a 元素的数组。</li><li>如果没有删除任何元素，则返回一个空数组。</li></ul><p>语法：<code>array.splice(index, howmany, element1, ....., elementX)</code></p><p>具体实现：</p><pre>    <code style="font-size: 20px; background-color: rgba(31,31,31,.31)">let myArray = [1, 2, 3, 4, 5];myArray[0] = myArray.splice(1, 1, myArray[0])[0]; # 返回索引为1的元素数组console.log(myArray); // [2, 1, 3, 4, 5]</code></pre><p>封装为函数：</p><pre>    <code style="font-size: 20px; background-color: rgba(31,31,31,.31)">const swapElements =(array, index1, index2) =&gt;myArray[index1] = myArray.splice(index2, 1, myArray[index1])[0];let myArray = [1, 2, 3, 4, 5];swapElements(myArray, 0, 1);console.log(myArray); // [2, 1, 3, 4, 5]</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上三种方法均可实现数组中任意两元素交换，为了方便理解和使用，最好使用 ES6 的<strong>解构赋值</strong>方法😉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的图片懒加载插件</title>
      <link href="/2024/06/15/img-lazy-loading/"/>
      <url>/2024/06/15/img-lazy-loading/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-lazyload-image-图片懒加载"><a href="#Hexo-lazyload-image-图片懒加载" class="headerlink" title="Hexo-lazyload-image 图片懒加载"></a>Hexo-lazyload-image 图片懒加载</h1><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>图片懒加载是提升网站性能和用户体验的常用方式之一，它仅把用户可见的部分显示图片，其余的都暂时不加载。反之，如果不使用它而使整个页面包含的所有图片一次性加载完成会造成页面部分资源加载不完整甚至导致白花花一片，造成用户体验不好。目前流行的做法是滚动动态加载，也就是懒加载——监听页面滚动事件，使显示在屏幕之外的图片默认不加载，随着用户浏览页面的滚动距离，图片进入了显示的范围，则触发图片的加载显示。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>让所有图片元素 src 指向一个小的站位图片比如 loading，并新增一个属性(如 data-original)存放真实图片地址。每当页面加载（或者滚动条滚动），使用 JS 脚本将可视区域内的图片 src 替换回真实地址，并做请求重新加载。</p><h2 id="网页优化"><a href="#网页优化" class="headerlink" title="网页优化"></a>网页优化</h2><ol><li><p>减少初始加载时间：在网页中，图片通常是较大的资源之一，一旦图片过多会导致页面加载时间较长。通过图片懒加载，可以减少初始页面的图片加载数量，将非必要的图片延迟加载，减少了首屏加载时间和服务器的压力，从而提高页面响应速度。</p></li><li><p>节省网络流量：图片懒加载可以在需要时才加载图片，避免了不必要的图片加载和传输。这对于数据流量有限或网络状况较差的用户来说，可以显著节省网络流量，提高用户体验。</p></li><li><p>提高缓存利用率：通过图片懒加载，可以将已加载的图片存储在本地或离线缓存中，以便在后续访问时直接使用，而不需要重新加载。这可以提高缓存利用率，减少网络请求次数，进一步提高性能和用户体验。</p></li><li><p>提高用户体验：图片懒加载可以根据用户的行为和需求来动态加载图片，提供更加个性化的用户体验。例如，当用户在页面上滚动或触发某些特定事件时，相关图片可以被动态加载和呈现，提供更加流畅和自然的交互体验。</p></li><li><p>优化图像质量：在加载图像时，可以使用不同的图像质量和压缩选项。通过懒加载技术，可以在需要时根据网络条件和设备性能选择最佳的图像质量或压缩选项。这有助于提高用户体验并减少带宽消耗。</p></li><li><p>…</p></li></ol><h2 id="推荐插件及示例"><a href="#推荐插件及示例" class="headerlink" title="推荐插件及示例"></a>推荐插件及示例</h2><p>本文章中使用了<a href="https://www.npmjs.com/package/hexo-lazyload-image">Hexo-lazyload-image</a>插件实现图片懒加载，可以刷新当前页面直接滚动至页面底部查看各个图片加载情况。</p><!-- 使用 Hexo 的img标签插入图片 --><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在你的 hexo 项目的_config.yml 配置文件中设置如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开启图片懒加载配置</span></span><br><span class="line">  <span class="attr">onlypost:</span> <span class="literal">false</span> <span class="comment"># optional</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="comment"># optional eg ./images/loading.gif</span></span><br><span class="line">  <span class="attr">isSPA:</span> <span class="literal">false</span> <span class="comment"># optional</span></span><br><span class="line">  <span class="attr">preloadRatio:</span> <span class="number">3</span> <span class="comment"># optional, default is 1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总之，图片懒加载解决了许多与网页性能和用户体验相关的问题，包括减少初始加载时间、节省网络流量、提高缓存利用率等等，在实际应用中，需要根据具体的需求和情况选择是否使用图片懒加载技术，并注意实现细节和安全性问题以确保应用程序的正常运行和用户的隐私安全。</p><img src="/images/image01.jpeg" class="" width="200" height="200" title="img1 200x200"><!-- 使用 html 的img标签插入图片 --><img src="/images/image01.jpeg" width="200" height="200" alt="img2 200x200"><!-- 在 Hexo 中使用 Markdown 的原生语法无法设置图片的大小 --><!-- <div style="width: 400px">    ![test markdown](https://s2.loli.net/2024/06/16/aAGtC6HzW9Lw8hc.jpg)</div> --><!-- 标准 Markdown 图片语法引用相关图片：![title](url) --><!-- 扩展了 Markdown 的插图语法(可设置图片大小)在主题source/js/hexo_resize_image.js--><!-- 用法：    1.可指定像素        ![指定宽高](/image/test.jpg?200x200)        ![仅指定width](/image/test.jpg?200x)        ![仅指定height](/image/test.jpg?x200)    2.可指定缩放比例，等比例缩放图片大小至 x %        ![指定比例](/image/test.jpg?40)    示例如下： --><p><img src="https://s2.loli.net/2024/06/16/aAGtC6HzW9Lw8hc.jpg?400x400" alt="img3 400x400"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图片懒加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/06/13/hello-world/"/>
      <url>/2024/06/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是本博客的第一篇文章，欢迎访问。 本博客使用 <a href="https://hexo.io/docs/">Hexo</a> + GitHub + <a href="https://github.com/blinkfox/hexo-theme-matery">matery</a> 完成搭建 。如果你在使用 Hexo 搭建个人博客时遇到疑难杂症，你可以在 <a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案，也可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a> 上寻找。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/commands#init">init</a></p><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="清理之前的生成文件"><a href="#清理之前的生成文件" class="headerlink" title="清理之前的生成文件"></a>清理之前的生成文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/commands#clean">Cleanning</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="部署更新后的网站到远程服务器"><a href="#部署更新后的网站到远程服务器" class="headerlink" title="部署更新后的网站到远程服务器"></a>部署更新后的网站到远程服务器</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><hr><p>以上为日常常用命令，更多命令查看[官网](<a href="https://hexo.io/docs/commands">Commands | Hexo</a>)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> live记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
